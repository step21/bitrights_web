<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>A first look on Solidity</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="hovercraft.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="600"><div class="step" step="0" data-x="0" data-y="0"><h1 id="solidity-design-goals">Solidity Design Goals</h1><blockquote><ul><li>contract-oriented language</li><li>statically typed</li><li>close to JavaScript</li><li>built-in natural language documentation</li><li>subset that allows formal proofs of correctness</li></ul></blockquote></div><div class="step" step="1" data-x="800" data-y="-200" data-scale="0.2"><pre class="highlight code Solidity"><span class="kd">contract</span> <span class="nx">ValueStorage</span> <span class="p">{</span>
  <span class="kt">uint</span> <span class="nx">value</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">set</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">newValue</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">value</span> <span class="o">=</span> <span class="nx">newValue</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">get</span><span class="p">()</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step" step="2" data-y="0" data-x="800" data-scale="0.2"><pre class="highlight code Solidity"><span class="kd">contract</span> <span class="nx">Coin</span> <span class="p">{</span>
  <span class="kd">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="kt">uint</span><span class="p">)</span> <span class="nx">balances</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">Coin</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">initial</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">minter</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">;</span>
    <span class="nx">balances</span><span class="p">[</span><span class="nx">minter</span><span class="p">]</span> <span class="o">=</span> <span class="nx">initial</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">/// Send $(amount) coins to $(to).
</span>  <span class="kd">function</span> <span class="nx">send</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">amount</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">to</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">balances</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">amount</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="nx">balances</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">]</span> <span class="o">-=</span> <span class="nx">amount</span><span class="p">;</span>
    <span class="nx">balances</span><span class="p">[</span><span class="nx">to</span><span class="p">]</span> <span class="o">+=</span> <span class="nx">amount</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step" step="3" data-x="800" data-y="200" data-scale="0.2"><pre class="highlight code Solidity"><span class="kd">contract</span> <span class="nx">Ballot</span> <span class="p">{</span>
  <span class="kd">struct</span> <span class="nx">vote</span> <span class="p">{</span>
    <span class="kt">bool</span> <span class="nx">voted</span><span class="p">;</span>
    <span class="kt">uint</span> <span class="nx">proposal</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">mapping</span><span class="p">(</span><span class="kt">address</span> <span class="o">=&gt;</span> <span class="nx">vote</span><span class="p">)</span> <span class="nx">votes</span><span class="p">;</span>
  <span class="c1">/// Vote for proposal number $(proposal).
</span>  <span class="kd">function</span> <span class="nx">voteFor</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">proposal</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">vote</span> <span class="nx">v</span> <span class="o">=</span> <span class="nx">votes</span><span class="p">[</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">voted</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">voted</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="nx">v</span><span class="p">.</span><span class="nx">proposal</span> <span class="o">=</span> <span class="nx">proposal</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step" step="4" id="compilation" data-x="0" data-y="1000" data-scale="1"><h1 id="compilation-process">Compilation Process</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>1 parse syntax</p></td><td><p>AST structure present</p></td></tr><tr><td><p>2 resolve identifiers</p></td><td><p>type names, variables, functions, ...</p></td></tr><tr><td><p>3 infer and check types</p></td><td><p>full AST available for
IDE (variable references, autocomplete, ...)</p></td></tr><tr><td><p>4 compile to assembly</p></td><td></td></tr><tr><td><p>5 optimize assembly</p></td><td></td></tr><tr><td><p>6 assembly to bytecode</p></td><td></td></tr></tbody></table><div style="height: 300px;"></div></div><div class="step" step="5" data-x="-400" data-y="1400" data-scale=".3"><h1 id="type-system">Type System</h1><blockquote><ul><li>all expressions have fixed type</li><li><em>no</em> operations involving different types</li><li>manual type conversions possible</li><li>automatic if no information lost</li></ul></blockquote><dl><dt>Types:</dt><dd><ul><li><tt>uintX</tt> / <tt>intX</tt> / <tt>hashX</tt>, X = 8, 16, ..., 256</li><li><tt>address</tt> = <tt>hash160</tt></li><li><tt>bool</tt></li><li><tt>mapping(A =&gt; B)</tt></li><li><tt>struct NAME { ... }</tt></li><li><tt>contract NAME { ... }</tt></li></ul></dd></dl></div><div class="step" step="6" data-x="-230" data-y="1380" data-scale="0.15"><iframe src="../compiler/index.html" style="background: #ffffff;" height="900" width="1300"></iframe></div><div class="step" step="7" id="optimizer" data-x="400" data-y="1400" data-scale=".3"><h1 id="optimizer">Optimizer</h1><p>Solidity does not compile to lll, but uses lll's assembly and optimizer.</p><p>&#x2192; Serpent, Solidity and lll benefit from optimizer improvements</p><p>Improvements done:</p><blockquote><ul><li>more rules for constant folding (<tt>PUSH1 7 PUSH1 0xff AND</tt> &#x2192; <tt>PUSH1 7</tt>)</li><li>POP optimization: side-effect free opcodes followed by POP are removed</li></ul></blockquote></div><div class="step" step="8" data-x="570" data-y="1380" data-scale="0.15"><iframe src="../compiler/index.html" style="background: #ffffff;" height="900" width="1300"></iframe></div><div class="step" step="9" data-x="0" data-y="2200" data-scale="1"><h1 id="memory-and-storage-management">Memory and Storage Management</h1><blockquote><ul><li>everything is zero-initialized</li><li>local variables only on the stack</li><li>actual memory not really used for now
(stack limit might hit Solidity)</li><li>storage allocated in contiguous way,
except for mappings:</li></ul><p><tt>offset = SHA3(own offset . key)</tt></p></blockquote></div><div class="step" step="10" data-x="0" data-y="3300" data-scale="1"><h1 id="other-contracts">Other Contracts</h1><p>Warning: Not yet implemented!</p><pre class="highlight code Solidity"><span class="nx">include</span> <span class="s2">"coin.sol"</span><span class="p">;</span>
<span class="nx">include</span> <span class="s2">"namereg.sol"</span><span class="p">;</span>
<span class="kd">contract</span> <span class="nx">Combination</span> <span class="p">{</span>
  <span class="kt">uint</span> <span class="nx">numContracts</span><span class="p">;</span>
  <span class="kd">mapping</span><span class="p">(</span><span class="kt">uint</span> <span class="o">=&gt;</span> <span class="nx">Coin</span><span class="p">)</span> <span class="nx">contracts</span><span class="p">;</span>
  <span class="nx">NameReg</span> <span class="nx">nameReg</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">Combination</span><span class="p">(</span><span class="kt">address</span> <span class="nx">nameRegAddr</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">nameReg</span> <span class="o">=</span> <span class="nx">NameReg</span><span class="p">(</span><span class="nx">nameRegAddr</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">create</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">initial</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">contracts</span><span class="p">[</span><span class="nx">numContracts</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Coin</span><span class="p">(</span><span class="nx">initial</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">send</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">coin</span><span class="p">,</span> <span class="kt">address</span> <span class="nx">to</span><span class="p">,</span> <span class="kt">uint</span> <span class="nx">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">contracts</span><span class="p">[</span><span class="nx">coin</span><span class="p">].</span><span class="nx">send</span><span class="p">(</span><span class="nx">amount</span><span class="p">,</span> <span class="nx">to</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step" step="11" data-x="0" data-y="4400" data-scale="1"><h1 id="outlook">Outlook</h1><p>Beginning of December: first usable version</p><p>After that: feedback from users</p><p>Areas of work:</p><ul><li>Tutorials, Documentation, Specification</li><li>Language Features</li><li>Optimizer</li><li>NatSpec Documentation</li><li>IDE (including deployment, etc.)</li><li>Static Analysis</li><li>Formal Verification</li><li>Bugfixes and Refactoring</li></ul></div><div class="step" step="12" data-x="0" data-y="5500" data-scale="1"><h1 id="planned-language-feature">Planned Language Feature</h1><p>Anonymous structs and even type-inferred anonymous structs
are planned for the future:</p><pre class="highlight code Solidity"><span class="kd">contract</span> <span class="nx">Example</span> <span class="p">{</span>
  <span class="kd">mapping</span><span class="p">((</span><span class="kt">uint</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">d</span><span class="p">,</span> <span class="kt">bool</span> <span class="nx">r</span><span class="p">))</span> <span class="nx">map</span><span class="p">;</span>
  <span class="kd">function</span> <span class="nx">f</span><span class="p">(</span><span class="kt">uint</span> <span class="nx">x</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="kt">uint</span> <span class="nx">y</span><span class="p">,</span> <span class="kt">bool</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="nx">map</span><span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">].</span><span class="nx">d</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span></pre></div><div class="step" step="13" data-x="0" data-y="6600" data-scale="1"><h1 id="ideas-for-the-optimizer">Ideas for the Optimizer</h1><blockquote><ul><li>inlining of function calls, will enable efficient library contracts (<tt>min</tt>,
<tt>find</tt>, ...)</li><li>reorganize local stack, determine variable lifetime and remove unused variables</li><li>if user feedback results in very bad performance: consider optimizing using
an intermediate language</li></ul></blockquote></div><div class="step" step="14" data-x="0" data-y="7700" data-scale="1"><h1 id="ideas-for-static-analysis">Ideas for Static Analysis</h1><blockquote><ul><li>enforce <tt>const</tt> functions</li><li><dl><dt>determine local value range</dt><dd><ul><li>detect overflows</li><li>detect semantically unreachable code</li></ul></dd></dl></li><li>estimate gas usage per source line (hilight expensive operations)</li><li>estimate min/max gas usage for specific transaction</li></ul></blockquote></div><div class="step" step="15" data-x="0" data-y="8800" data-scale="1">&nbsp;</div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Left, Down, Page Down</th><td>Next slide</td></tr><tr><th>Right, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>